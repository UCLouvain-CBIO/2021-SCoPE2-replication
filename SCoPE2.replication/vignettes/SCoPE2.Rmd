---
title: "Replicate Specht et al. 2019 mass spectrometry-based single-cell proteomics analysis"
author:
  - Christophe Vanderaa^[christophe.vanderaa@uclouvain.be], Computational Biology, UCLouvain
  - Laurent Gatto, Computational Biology, UCLouvain
abstract: "Recent advances in sample preparation, processing and mass spectrometry (MS) have allowed the emergence of MS-based single-cell proteomics (SCP). This vignette presents a robust and standardized workflow to reproduce the data analysis of SCoPE2, one of the pioneering works in the field developed by the Slavov Lab. The implementation uses well-defined Bioconductor classes that provide powerful tools for single-cell RNA sequencing and for shotgun proteomics. We demonstrate that our pipeline can reproduce the SCoPE2 analysis using only a few lines of code."
output:
  BiocStyle::html_document:
    self_contained: yes
    toc: true
    toc_float: true
    toc_depth: 2
    code_folding: show
bibliography: refs.bib
date: "`r BiocStyle::doc_date()`"
package: "`r BiocStyle::pkg_ver('SCoPE2.replication')`"
vignette: >
  %\VignetteIndexEntry{Complete replication of the SCoPE2 data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
# bookdown::pdf_document2:
#   toc: true
# bookdown::html_document2:
#     code_folding: show
#     toc: true
#     toc_float: true
knitr::opts_chunk$set(fig.width = 7,
                      fig.height = 5,
                      fig.align = "center",
                      out.width = "70%")
```


```{r, echo=FALSE}
## Store current time for later record
timeStart <- Sys.time()
```

# Introduction

SCoPE2 (@Specht2019-jm) is the first mass spectrometry (MS)-based
single cell proteomics (SCP) protocol that has been used to profile
thousands of proteins in thousands of cells. This is a technical
milestone for SCP and it opens the door for fine-grain understanding
of biological processes within and between cells at the protein level.
The emergence of SCP data leads to the need of new computational
developments that can deal with the specificities and challenges of
this new type of data.

Although the authors provided all code and data required for fully
reproducing their analysis, the code is difficult to read, implements
many functions from scratch, and is based on generic table formats not
suited for easy SCP data manipulation. This makes their workflow
difficult to re-use for other analyses. Our goal is to bridge the gap
between data acquisition and data interpretation by providing a new
computational framework that is tailored for MS-SCP data. The SCoPE2
dataset is an ideal dataset to showcase its robustness and its ease
of use.

### Data framework and `scp`

Our first contribution is the development of a new data framework that
combines two existing Bioconductor classes: the `SingleCellExperiment`
that provides an interface to many cutting edge methods for single-cell
analysis and `QFeatures` that facilitates manipulation and processing
of MS-based quantitative data. See the
[`scp` vignette](http://www.bioconductor.org/packages/release/bioc/vignettes/scp/inst/doc/scp.html)
for more detailed information about the data structure. The `scp`
package provides functionality for manipulating this MS-SCP data
structure. `scp` is an extension to the `QFeatures` package. The
emphasis is put on the standardization and the thorough documentation
of the functions in order to (i) facilitate analysis for non-experts,
(ii) provide an efficient environment for processing (large) MS-SCP data
sets, (iii) be compatible for both multiplexed and label free
quantification, the two main protocols for MS-SCP and (iv) facilitate
the inclusion of external methods for promoting continuous improvement
of the MS-SCP data analyses.

The required packages for running this workflow are listed below.

```{r libraries, results='hide', message=FALSE}
## Core packages of this workflow
library(SingleCellExperiment)
library(QFeatures)
library(scpdata)
library(scp)
## Utility packages for data manipulation and visualization
library(tidyverse)
library(patchwork)
```

### `scpdata` and the SCoPE2 dataset

We also implemented a data package called `scpdata`. It distributes
published MS-SCP datasets, such as the SCoPE2 dataset. The datasets
were downloaded from the data source provided in the publication and
formatted to a `QFeatures` object so that it is compatible with our
software. The underlying data storage is based on the `ExperimentHub`
package that provides a cloud-based storage infrastructure.

The SCoPE2 dataset (@Specht2019-jm) is provided at different levels of
processing:

* The **raw data** files that were generated by the mass-spectrometer
software.
* A **PSM data** table obtained from the MaxQuant software that
performs spectrum identification and quantification. The provided
table was further processed using DART-ID (@Chen2019-uc) to improve
the identification rate.
* A **peptide data** table obtained from the SCoPE2 analysis script.
* A **protein data** table obtained as the final table from the SCoPE2
analysis script.

The workflow starts with the PSM table and will generate the peptide
and the protein data. The authors provided the PSM dataset as a data
table (`data.frame`). The files can be downloaded from SCoPE2
repository of the Slavov Lab [website](http://scope2.slavovlab.net/).
The formatted SCoPE2 dataset can be retrieved from the `scpdata`
package with the `specht2019v3()` function. Note that `v3` stands for
the third version release of the data in October 2020.

```{r load_data}
scp <- specht2019v3()
```

The data contain 179 different `SingleCellExperiment` objects that we
refer to as **assays**. Each assay contains expression data along with
feature metadata. Below, we show the overview of the `scp`
dataset.

```{r data overview}
scp
```

177 out of the 179 assays are PSM data, each assay corresponding to a
separate MS run. 63 contain 11 columns and 114 contain 16 columns.
This is because the SCoPE2 protocol first included TMT-11
multiplexing, but soon the TMT-16 multiplexing was released and the
authors decided to switch to the latter to increase the throughput of
the technique. Notice that the assays were also acquired in 4
chromatographic batches. Here is an overview of the distribution of
the assays across the TMT and chromatographic batches.

```{r, fig.width = 4, fig.height = 3}
colData(scp) %>%
    data.frame %>%
    select(c(Set, lcbatch)) %>%
    unique %>%
    mutate(TMT = ifelse(grepl("16plex", Set), "TMT16", "TMT11")) %>%
    ggplot() +
    aes(x = lcbatch,
        fill = TMT) +
    geom_histogram(stat = "count") +
    xlab("Chromatographic batch") +
    theme_classic()
export::graph2pdf(file = "../figs/drafts/batch_design.pdf", height = 3, width = 4)
```

The dataset also contains a `peptides` assay and a
`proteins` assay that hold peptide and protein level information,
respectively. The objective of this vignette is to produce the
`peptides` and `proteins` assays from the 177 PSM assays following the
same procedure as the SCoPE2 script but using standardized
functionalities.

We extract the `peptides` and `proteins` assays and keep them for
later benchmarking. Using double brackets `[[...]]` extracts the
desired assay as a `SingleCellExperiment` object. On the other hand,
using simple brackets `[row, col, assay]` subsets the desired
elements/assays but preserves the `QFeatures` data structure.

```{r}
peptides_SCoPE2 <- scp[["peptides"]]
proteins_SCoPE2 <- scp[["proteins"]]
scp <- scp[, , -(178:179)]
```

To avoid confusions during later benchmarking of the replication, we
name the peptide and protein data sets generated by the SCoPE2 script
`peptides_SCoPE2` and `proteins_SCoPE2`, respectively.

## The SCoPE2 workflow

We here give a schematic overview of the different processing steps
performed by the SCoPE2 script. Note that we here used the part of the
script that performs the stringent feature selection (see the original
paper for more details).

```{r SCoPE2_workflow, results='markup', fig.cap="Overview of the SCoPE2 workflow.", echo=FALSE, out.width='100%', fig.align='center'}
knitr::include_graphics("../figs/workflow_SCoPE2.png", error = FALSE)
```

The SCoPE2 code provided along with the article can be retrieved from
[this GitHub repository](https://github.com/SlavovLab/SCoPE2/blob/master/code/SCoPE2_analysis.R).
The objective of this vignette is to replicate the SCoPE2 script while
providing standardized, easy-to-read, and well documented code. We
will demonstrate the success of the replication with a little
benchmarking of our results against the data provided by the authors.
Finally, we will perform some further data exploration to highlight
the remaining challenges that still require to be tackled in MS-based
SCP.

# Filter the PSM data

The SCoPE2 analysis starts with filtering low-confidence PSMs. Each
PSM assay contains feature meta-information that are stored in the
assay `rowData`. The `QFeatures` package allows to quickly filter
the rows of an assay by using these information. The available
variables in the `rowData` are listed below for each assay.

```{r}
rowDataNames(scp)
```

## Filter out failed runs based on PSM content

First, only the assays that have sufficient PSMs are kept. The authors
keep an assay if it has over 500 PSMs. Before filtering, let's first
look at the distribution of the number of PSMs per assay. Note that we
can easily extract the number of rows (here PSMs) and the number of
columns (TMT channels) of each assay using the `dims` function
implemented in `QFeatures`.

```{r dims}
nPSMs <- dims(scp)[1, ]
```

Let's have a look at the number of features that were identified in
the different runs.

```{r plot_dims, message = FALSE}
ggplot(data.frame(nPSMs)) +
    aes(x = nPSMs) +
    geom_histogram() +
    geom_vline(xintercept = 500)
```

4 assays have very few number of PSMs, probably because those runs
failed. They are hence below the threshold of 500 and are removed from
the analysis. To perform this, we take advantage of the subsetting
method of a `QFeatures` object. It can be seen as a three-order array:
$features \times samples \times assay$. Hence, `QFeatures` supports
three-order subsetting `x[rows, columns, assays]`.

```{r remove_failed_runs}
scp <- scp[, , nPSMs > 500]
```

You may notice that a warning is thrown when performing the subsetting
step. This is because, as we expected, a few assays were dropped. We
can find them back in the `metadata` slot:

```{r metadata}
metadata(scp)
```


## Filter out PSMs with high false discovery rate

Next, SCoPE2 filters PSMs based on the false discovery rate (FDR) for
identification. As mentioned in the introduction, the PSM data were
already processed with DART-ID (@Chen2019-uc), a python software that
updates the confidence in peptide identification using an Bayesian
inference approach. DART-ID outputs for every PSM the updated
posterior error probability (PEP). Filtering on the PEP is too
conservative and it is rather advised to filter based on FDR
(@Kall2008-hb). To control for the FDR, we need to compute q-values,
that correspond to the minimal FDR threshold that would still select
the associated feature.

We can easily compute q-values from the PEPs computed by MaxQuant or
updated by DART-ID using the `pep2qvalue` function. In the SCoPE
workflow, the features are selected based on the FDR at PSM level and
at protein level. The PEP information (`dart_PEP`) as well as the
protein information (`protein`) are retrieved from the `rowData` of
each assay. The function will store the computed q-values in the
`rowData` and we give the name of `qvalue_psm` and `qvalue_protein`
for the PSM and proteins q-values, respectively.

```{r}
scp <- pep2qvalue(scp,
                  i = names(scp),
                  PEP = "dart_PEP",
                  rowDataName = "qvalue_psm")
scp <- pep2qvalue(scp,
                  i = names(scp),
                  groupBy = "protein",
                  PEP = "dart_PEP",
                  rowDataName = "qvalue_protein")
```

We can extract the q-values from the `rowData` of several assays using
the `rowDataToDF` function. It takes the `rowData` of interest and
returns a single `DataFrame` table with variables of interest. We plot
the q-values along with the DART-ID PEPs using `ggplot2` facets.

```{r, message=FALSE}
rowDataToDF(scp,
            i = names(scp),
            vars = c("dart_PEP", "qvalue_psm", "qvalue_protein")) %>%
    data.frame %>%
    pivot_longer(cols = c("dart_PEP", "qvalue_psm", "qvalue_protein"),
                 names_to = "measure") %>%
    ggplot(aes(x = value)) +
    geom_histogram() +
    geom_vline(xintercept = 0.1) +
    scale_x_log10() +
    facet_grid(rows = vars(measure))
```

We filter the PSMs to control for a 1\% PSM and protein FDR. We can
easily perform this on our `QFeatures` object by using the
`filterFeatures` function. The q-values are directly accessed from the
`rowData` of each assay.

```{r filter_FDR}
scp <- filterFeatures(scp,
                      ~ qvalue_psm < 0.01 & qvalue_protein < 0.01)
```

## Filter out contaminants

We will now remove PSMs that were matched to contaminant proteins (the
protein name starts with `CON`) or to the decoy database (the protein
name starts with `REV`). Again, `filterFeatures` can directly access
the protein names from the `rowData`.

```{r filter_contaminants}
scp <- filterFeatures(scp,
                      ~ !grepl("REV|CON", protein))
```

## Filter out noisy spectra

A PIF (parental ion fraction) smaller than 80 \% indicates the
associated spectra is contaminated by co-isolated peptides and
therefore the quantification becomes unreliable. The PIF was computed
by MaxQuant and is readily available for filtering.

```{r filter_PIF}
scp <- filterFeatures(scp,
                      ~ !is.na(PIF) & PIF > 0.8)
```

## Filter out PSMs with high sample to carrier ratio

The PSMs are next filtered based on the sample to carrier ratio (SCR),
that is the reporter ion intensity of a single-cell sample divided by
the reporter ion intensity of the carrier (200 cells) acquired during
the same run as the sample. It is expected that the carrier
intensities are much higher than the single-cell intensities. We
implemented the `computeSCR` function that computes the SCR for each
PSM averaged over all samples of interest in a given assay. A PSM is
removed when the mean SCR exceeds 10 \%. To perform this, we need to
tell the function which columns are the samples of interest and which
is the carrier. The `colData` of the `QFeatures` object is used to
define this.

```{r}
table(scp$SampleType)
```

In this dataset, `SampleType` gives the type of sample that is present
in each TMT channel. The SCoPE2 protocol includes 5 types of samples:
* The carrier channels (`Carrier`) contain 200 cell equivalents and
  are meant to boost the peptide identification rate.
* The normalization channels (`Reference`) contain 5 cell equivalents
  and are used to partially correct for between-run variation.
* The unused channels (`Unused`) are channels that are left empty due
  to isotopic cross-contamination by the carrier channel.
* The blank channels (`Blank`) contain samples that do not contain any
  cell but are processed as single-cell samples.
* The single-cell sample channels contain the single-cell samples of
  interest (`Macrophage` or `Monocyte`).

The `computeSCR` function expects the user to provide a pattern
(following regular expression syntax) that uniquely identifies a
carrier channel in each run and the samples or blanks. The function
will store the mean SCR of each feature in the `rowData` of each
assay.

```{r computeSCR}
scp <- computeSCR(scp,
                  i = names(scp),
                  colDataCol = "SampleType",
                  carrierPattern = "Carrier",
                  samplePattern = 4:16)
```

Before applying the filter, we plot the distribution of the mean SCR.

```{r, warning=FALSE, message=FALSE}
rowDataToDF(scp,
            i = names(scp),
            vars = ".meanSCR") %>%
    data.frame %>%
    ggplot(aes(x = .meanSCR)) +
    geom_histogram() +
    geom_vline(xintercept = 0.1) +
    scale_x_log10()
```

A great majority of the PSMs have a mean SCR that is lower than 10\%,
as expected. Interestingly, the mode of the distribution is located at
~1\%. This is expected since every sample channel contains a
single-cell and the carrier contains 200 cells leading to an expected
ratio of 0.5\%. We remove the PSMs for which the mean SCR exceeds the
10\% threshold.

```{r}
scp <- filterFeatures(scp,
                      ~ !is.na(.meanSCR) &
                          !is.infinite(.meanSCR) &
                          .meanSCR < 0.1)
```

# Normalize to reference

In order to partially correct for between-run variation, SCoPE2
computes relative reporter ion intensities. This means that
intensities measured for single-cells are divided by the reference
channel containing 5-cell equivalents. We use the `divideByReference`
function that divides channels of interest by the reference channel.
Similarly to `computeSCR`, we can point to the samples and the
reference columns in each assay using the annotation contained in the
`colData`. We will here divide all columns (using the regular
expression wildcard `.`) by the reference channel (`Reference`).
Notice that when taking all samples we also include the reference
channel. Hence, from now on, the reference channels will contain only
`1`s.

```{r}
scp <- divideByReference(scp,
                         i = names(scp),
                         colDataCol = "SampleType",
                         samplePattern = ".",
                         refPattern = "Reference")
```

# Aggregate PSM data to peptide data

Now that the PSM assays are processed, we can aggregate them to
peptides. This is performed using the `aggregateFeaturesOverAssays`
function. This is a wrapper function in `scp` that sequentially calls
the `aggregateFeatures` from the `QFeatures` package over the
different assays. For each assay, the function aggregates several PSMs
into a unique peptide given an aggregating variable in the `rowData`
(peptide sequence) and a user-supplied aggregating function (the
median for instance). Regarding the aggregating function, the SCoPE2
analysis removes duplicated peptide sequences per run by taking the
first non-missing value. While better alternatives are documented in
`QFeatures::aggregateFeatures`, we still use this approach for the
sake of replication and for illustrating that custom functions can
be applied.

```{r remove.duplicates}
remove.duplicates <- function(x)
    apply(x, 2, function(xx) xx[which(!is.na(xx))[1]] )
```

The aggregated peptide assays must be given a name. We here used the
original names with `peptides_` at the start.

```{r peptideAssays}
peptideAssays <- paste0("peptides_", names(scp))
```

We now have all the required information to aggregate the PSMs in the
different batches to peptides.

```{r, message = FALSE}
scp <- aggregateFeaturesOverAssays(scp,
                                   i = names(scp),
                                   fcol = "peptide",
                                   name = peptideAssays,
                                   fun = remove.duplicates)
```

Under the hood, the `QFeatures` architecture preserves the
relationship between the aggregated assays. See `?AssayLinks` for more
information on relationships between assays. Notice that
`aggregateFeaturesOverAssays` created as many new assays as the number
of supplied assays.

```{r}
scp
```

# Join the SCoPE2 sets in one assay

Up to now, we kept the data belonging to each MS run in separate
assays. We now combine all batches into a single assay. This can
easily be done using the `joinAssays` function from the `QFeatures`
package.

We however need to account for an issue. The `joinAssays` will only
keep the metadata variables that have the same value between matching
rows. However, some peptide sequences map to one protein in one run
and to another protein in another run. Hence, the protein sequence is
not constant for all peptides and is removed during joining. It is
important we keep the protein sequence in the `rowData` since we will
later need it to aggregate peptides to proteins. To avoid this issue,
we replace the problematic peptides to protein mappings through
majority vote.

```{r, message=FALSE}
scp %>%
    rowDataToDF(i = names(scp)[1:173],
                vars = c("peptide", "protein")) %>%
    data.frame %>%
    group_by(peptide) %>%
    ## The majority vote happens here
    mutate(protein = names(sort(table(protein),
                                decreasing = TRUE))[1]) %>%
    select(peptide, protein) %>%
    filter(!duplicated(peptide, protein)) ->
    ppMap
for (i in peptideAssays) {
    pep <- rowData(scp[[i]])$peptide
    rowData(scp@ExperimentList@listData[[i]])$protein <-
        ppMap$protein[match(pep, ppMap$peptide)]
}
```

This code chunk is hard to read and is not standardized.  conceptu

**@todo** comment on this. The issue is that we are working with
shared peptides... Discuss with Laurent.

Now that the peptides are correctly matched to proteins, we can join
the assays.

```{r}
scp <- joinAssays(scp,
                  i = peptideAssays,
                  name = "peptides")
```

`joinAssays` has created a new assay called `peptides` that combines
the previously aggregated peptide assays.

```{r}
scp
```

# Format the missing data

SCoPE2 performs a cleaning step were zero and infinite values are
replaced by NAs. The `infIsNA` and the `zeroIsNA` functions are
provided by the `QFeatures` package.

```{r}
scp <- infIsNA(scp, i = "peptides")
scp <- zeroIsNA(scp, i = "peptides")
```

# Filter single-cells based on median CV

The SCoPE2 script proceeds with filtering the single-cell. The
filtering is mainly based on the median coefficient of variation (CV)
per cell. The median CV measures the consistency of quantification for
a group of peptides that belong to a protein. We remove cells that
exhibit high median CV over the different proteins. We compute the
median CV per cell using the `medianCVperCell` function from the `scp`
package. The function takes the `peptides_filter1` assay, protein and
peptide information from the assay `rowData`, and the batch names in
the `colData` of the `QFeatures` object. The peptide and batch
information are required to perform normalization prior to the CV
computation. Protein information is required since the CV are computed
at the protein level.

```{r}
scp <- computeMedianCV_SCoPE2(scp,
                              i = "peptides",
                              proteinCol = "protein",
                              peptideCol = "peptide",
                              batchCol = "Set")
```

The computed CVs are stored in the `colData` of the `peptides_filter1` assay and
holds the median CV per cell computed using at least 5 observations (peptides).
The main interest of computing the median CV per cell is to filter cells with
reliable quantification. The blank samples are not expected to have reliable
quantifications and hence can be used to estimate an empirical null distribution
of the CV. This distribution helps defining a threshold that filters out
single-cells that contain noisy quantification.

The sample annotation is contained in the `colData` of the `QFeatures` object.
We will therefore first transfer the sample annotation from the `QFeatures`
object to the `SingleCellExperiment` assay using the `transferColDataToAssay`
function. We then directly extract the assay `colData` that contains all the
required information for plotting.

```{r, message = FALSE, warning = FALSE}
getWithColData(scp, i = "peptides") %>%
    colData %>%
    data.frame %>%
    filter(SampleType %in% c("Macrophage",  "Monocyte", "Blank")) %>%
    ggplot(aes(x = MedianCV,
               fill = SampleType)) +
    geom_histogram() +
    geom_vline(xintercept = 0.365)
```

We can see that the protein quantification for single-cells are much more
consistent within cells than the blank channels. A threshold of 0.4 best
separates single-cells from empty channels.

We keep the cells that pass the median CV threshold. Furthermore, we
keep macrophages and monocytes as those represent the samples of
interest. Now the quality control and filtering is performed, we can
remove the other channels.

We have already demonstrated how to remove assays from the dataset,
but we can apply a similar subsetting for the samples present in the
`colData`. Recall that the second entry in the `[` subsetting method
is for samples.

```{r}
scp <- scp[, scp$MedianCV < 0.365 &
               scp$SampleType %in% c("Macrophage", "Monocyte"), ]
```

**@todo** this is slow and requires optimization.

```{r}
scp
```


# Process the peptide data

In the SCoPE2 analysis, the peptide data is first transformed before it is
aggregated to proteins. The transformation steps are: normalization, filter
peptides based on missing data and log-transformation.

## Normalization

The columns (samples) of the peptide data are first normalized by dividing the
relative intensities by the median relative intensities. Then, the rows
(peptide) are normalized by dividing the relative intensities by the
mean relative intensities. The normalized data is stored in a separate assay.

```{r}
scp %>%
    ## Scale columns with median
    sweep(i = "peptides",
          MARGIN = 2,
          FUN = "/",
          STATS = colMedians(assay(.[["peptides"]]),
                             na.rm = TRUE),
          name = "peptides_norm1") %>%
    ## Scale rows with mean
    sweep(i = "peptides_norm1",
          MARGIN = 1,
          FUN = "/",
          STATS = rowMeans(assay(.[["peptides_norm1"]]),
                           na.rm = TRUE),
          name = "peptides_norm2") ->
    scp
```

## Remove peptides with high missing rate

Peptides that contain many missing values are not informative. Therefore, we
remove those with more than 99 \% missing data. This is done using the
`filterNA` function from `QFeatures`.

```{r}
scp <- filterNA(scp,
                i = "peptides_norm2",
                pNA = 0.99)
```

## Log-transformation

The last processing step of the peptide data before aggregating to proteins is
to log-transform the data. SCoPE2 uses a base 2 log-transformation.

```{r}
scp <- logTransform(scp,
                    base = 2,
                    i = "peptides_norm2",
                    name = "peptides_log")
```

## The SCoPE2 peptide data

Before exporting the data as `Peptides-raw.csv`, the authors performed
an additional normalization step. This step is however not considered
in the remainder of the workflow.

```{r}
scp %>%
    ## Center columns with median
    sweep(i = "peptides_log",
          MARGIN = 2,
          FUN = "-",
          STATS = colMedians(assay(.[["peptides_log"]]),
                             na.rm = TRUE),
          name = "peptides_log_norm1") %>%
    ## Center rows with mean
    sweep(i = "peptides_log_norm1",
          MARGIN = 1,
          FUN = "-",
          STATS = rowMeans(assay(.[["peptides_log_norm1"]]),
                           na.rm = TRUE),
          name = "peptides_scp") ->
    scp
```

We names the last assay `peptides_scp`. We will contrast this data
matrix to `peptides_SCoPE2` later in this vignette to assess the
fidelity of the replication.

# Aggregate peptide data to protein data

Similarly to aggregating PSM data to peptide data, we can aggregate peptide data
to protein data using the `aggregateFeatures` function. Note that we here use
the median as a summarizing function.

```{r}
scp <- aggregateFeatures(scp,
                         i = "peptides_log",
                         name = "proteins",
                         fcol = "protein",
                         fun = matrixStats::colMedians, na.rm = TRUE)
```

# Process the protein data

The protein data is processed in three steps: normalization, imputation (using
the KNN algorithm) and batch correction (using the `ComBat` algorithm).

## Normalization

Normalization is performed similarly to peptide normalization. We use the same
functions, but since the data were log-transformed at the peptide level, we
subtract by the statistic (median or mean) instead of dividing.

```{r}
scp %>%
    ## Center columns with median
    sweep(i = "proteins",
          MARGIN = 2,
          FUN = "-",
          STATS = colMedians(assay(.[["proteins"]]),
                             na.rm = TRUE),
          name = "proteins_norm1") %>%
    ## Center rows with mean
    sweep(i = "proteins_norm1",
          MARGIN = 1,
          FUN = "-",
          STATS = rowMeans(assay(.[["proteins_norm1"]]),
                           na.rm = TRUE),
          name = "proteins_norm2") ->
    scp
```


## Imputation

The protein data contains a lot of missing values. The graph below shows the
distribution of the proportion missingness in cells. Cells contain on average
over 75 \% missing values!

```{r, message=FALSE}
longFormat(scp[, , "proteins_norm2"]) %>%
    data.frame %>%
    group_by(colname) %>%
    summarize(missingness = mean(is.na(value))) %>%
    ggplot(aes(x = missingness)) +
    geom_histogram()
```

The missing data is imputed using K nearest neighbors. The SCoPE2 script runs
KNN with k = 3. We made a wrapper around the author's code to apply imputation
to our `QFeatures` object.

```{r}
scp <- scp_imputeKNN(scp,
                     i = "proteins_norm2",
                     name = "proteins_impd",
                     k = 3)
```

`QFeatures` also provides KNN imputation by calling to the `impute::impute.knn`
function. However, the implementation is different in the sense that SCoPE2
performs KNN imputation in the sample space, meaning that data from neighbouring
cells are used to impute, whereas `impute::impute.knn` performs KNN imputation
in the gene space, meaning that data from neighbouring genes are used to impute
the missing values. We provide the code for KNN imputation with `QFeatures` but
do not run in order to reproduce the SCoPE2 analysis.

```{r, eval = FALSE}
scp <- impute(scp,
              i = "proteins_norm2",
              method = "knn",
              k = 3, rowmax = 1, colmax= 1,
              maxp = Inf, rng.seed = 1234)
```

## Batch correction

The final step is to model the remaining batch effects and correct for
it. The data were acquired as a series of MS runs. Recall we had 177
assays at the beginning of the workflow. Each MS run can be subjected
to small technical perturbations that lead to differences in the data.
This can be corrected to avoid attributing biological effects to
technical effects. The `ComBat` algorithm (@Johnson2007-nc) is used in
the SCoPE2 script  to correct for those batch effects. `ComBat` is
part of the `sva` package. It requires a batch variable, in this case
the LC-MS/MS run, and adjusts for batch effects, while protecting
variables of interest, the sample type in this case. All the
information is contained in the `colData` of the `QFeatures` object.
We first extract the assays with the associate `colData`.

```{r}
sce <- getWithColData(scp, "proteins_impd")
```

We next store the batch variable and create the design matrix. We then
call the functions and overwrite the data matrix. Recall the data
matrix can be accessed using the `assay` function. Note also that we
here use `ComBatv3.34` that was loaded at the beginning of the
vignette (not shown). This function was taken from an older version of
the `sva` package (version `3.34.0`). This is to replicate the SCoPE2
results. More recent versions have implemented a check for
within-batch invariant proteins that will ignore batch correction
for a protein if at least one of the batch contain constant values.

```{r, results='hide', message=FALSE}
batch <- colData(sce)$Set
model <- model.matrix(~ SampleType, data = colData(sce))
assay(sce) <- ComBatv3.34(dat = assay(sce),
                          batch = batch,
                          mod = model)
```

Finally, we add the batch corrected assay to the `QFeatures` object
and create the feature links.

```{r}
scp %>%
    addAssay(y = sce,
             name = "proteins_batchC") %>%
    addAssayLinkOneToOne(from = "proteins_impd",
                         to = "proteins_batchC") ->
    scp
```

## The SCoPE2 protein data

Before exporting the data as `Proteins-processed.csv`, the authors
performed an additional normalization step.

```{r}
scp %>%
    ## Center columns with median
    sweep(i = "proteins_batchC",
          MARGIN = 2,
          FUN = "-",
          STATS = colMedians(assay(.[["proteins_batchC"]]),
                             na.rm = TRUE),
          name = "proteins_batchC_norm1") %>%
    ## Center rows with mean
    sweep(i = "proteins_batchC_norm1",
          MARGIN = 1,
          FUN = "-",
          STATS = rowMeans(assay(.[["proteins_batchC_norm1"]]),
                           na.rm = TRUE),
          name = "proteins_scp") ->
    scp
```

We named the last assay `proteins_scp`. We will contrast this data
matrix to `proteins_SCoPE2` later in the next section to assess the
fidelity of the replication.

```{r echo = FALSE, eval = FALSE, results = "hide"}
# save(scp, file = "output/vignette_final.RData")
# load("output/vignette_final.RData")
```

# Benchmarking the replication

We will now compare the data that were provided by Specht and
colleagues with the data generated in this vignette. We compare the
peptide and the protein data.

## Compare the selected cells

One of the above section filtered the single cells based on the median
coefficient of variation per cell. We will check that we could indeed
reproduce the SCoPE2 cell filter. Note that the peptide and protein
data contain the same set of cells.

```{r, echo=FALSE, fig.width = 3, fig.height = 3, message = FALSE}
cells_scope2 <- colnames(peptides_SCoPE2)
cells_scp <- colnames(scp[["peptides_scp"]])
cells <- unique(c(cells_scope2, cells_scp))
data.frame(SCoPE2 = cells %in% cells_scope2,
           scp = cells %in% cells_scp) %>%
    mutate_all(function(x) ifelse(x, "present", "absent")) %>%
    group_by(SCoPE2, scp) %>%
    summarise(count = n()) %>%
    mutate(success = SCoPE2 == "present" & scp == "present") %>%
    ggplot() +
    aes(x = SCoPE2,
        y = scp,
        col = success,
        label = count) +
    geom_point(aes(size = count)) +
    geom_text(nudge_y = 0.2) +
    scale_y_discrete(limits = c("absent", "present")) +
    scale_color_manual(values = c("orange2", "green4")) +
    theme_minimal() +
    theme(legend.position = "none",
              axis.title.y = element_text(vjust = 0),
              axis.text.y = element_text(angle = 90, hjust = 0.5)) +
    ggtitle("Filtered cells") ->
    cell_sel
cell_sel
```

The `scp` filtering step keep 9 additional cells (0.6 \% out of all
cells) compared to SCoPE2.


## Compare peptide data

The SCoPE2 and the `scp` peptide data have comparable dimensions,
although they are not exactly the same. Our workflow kept 10
additional peptides out of 9364. Similarly to the filtered cells, this
difference is negligible and demonstrate an almost perfect replication
of the filtering steps.

```{r, echo=FALSE, fig.width = 3, fig.height = 3, message = FALSE}
peps_scope2 <- rownames(peptides_SCoPE2)
peps_scp <- rownames(scp[["peptides_scp"]])
peps <- unique(c(peps_scope2, peps_scp))
data.frame(SCoPE2 = peps %in% peps_scope2,
           scp = peps %in% peps_scp) %>%
    mutate_all(function(x) ifelse(x, "present", "absent")) %>%
    group_by(SCoPE2, scp) %>%
    summarise(count = n()) %>%
    mutate(success = SCoPE2 == "present" & scp == "present") %>%
    ggplot() +
    aes(x = SCoPE2,
        y = scp,
        col = success,
        label = count) +
    geom_point(aes(size = count)) +
    geom_text(nudge_y = 0.2) +
    scale_y_discrete(limits = c("absent", "present")) +
    scale_color_manual(values = c("orange2", "green4")) +
    theme_minimal() +
    theme(legend.position = "none",
          axis.title.y = element_text(vjust = 0),
          axis.text.y = element_text(angle = 90, hjust = 0.5)) +
    ggtitle("Filtered peptides") ->
    peptide_sel
peptide_sel
```

To assess the difference between the data matrices, we intersect the
peptides and the cells to have comparable matrices. The range of the
differences between the 2 datasets is contained in -0.2 and 0.2, with
a very sharp . This
corresponds to approximately 2 \% of the total range of the data
(-8.941, 6.166). Therefore, we can say that the `scp` workflow could
accurately replicate the SCoPE2 peptide data.

```{r, echo=FALSE, fig.width = 3, fig.height = 3, message = FALSE}
rows <- intersect(rownames(peptides_SCoPE2),
                  rownames(scp[["peptides_scp"]]))
cols <- intersect(colnames(peptides_SCoPE2),
                  colnames(scp[["peptides_scp"]]))
err <- assay(peptides_SCoPE2)[rows, cols] -
    assay(scp[["peptides_scp"]])[rows, cols]
data.frame(difference = as.vector(err[!is.na(err)])) %>%
    mutate(difference = difference) %>%
    ggplot() +
    geom_histogram(aes(x = difference), bins = 50) +
    xlab("SCoPE2 - scp") +
    scale_y_continuous(labels = scales::scientific) +
    theme_minimal() +
    ggtitle("Peptide data") ->
    peptide_diff
peptide_diff
```

## Compare protein data

Similarly to the peptide data, the SCoPE2 and the `scp` protein data
contain different but highly overlapping (99.28 \%) sets of proteins.
It is expected to see more proteins in the `scp` results with respect
to `SCoPE2` because this was already seen for the peptide data. However,
some proteins are only found in SCoPE2. This is a consequence of the
remapping of peptides to proteins that occurred when joining together
all the peptides assays in one. This step was required by `scp` to
properly aggregate peptides to proteins, but was not considered in the
SCoPE2 workflow.

```{r, echo=FALSE, fig.height = 3, fig.width = 3, message = FALSE}
prots_scope2 <- rownames(proteins_SCoPE2)
prots_scp <- rownames(scp[["proteins_scp"]])
prots <- unique(c(prots_scope2, prots_scp))
data.frame(SCoPE2 = prots %in% prots_scope2,
           scp = prots %in% prots_scp) %>%
    mutate_all(function(x) ifelse(x, "present", "absent")) %>%
    group_by(SCoPE2, scp) %>%
    summarise(count = n()) %>%
    mutate(success = SCoPE2 == "present" & scp == "present") %>%
    ggplot() +
    aes(x = SCoPE2,
        y = scp,
        col = success,
        label = count) +
    geom_point(aes(size = count)) +
    geom_text(nudge_y = 0.2) +
    scale_color_manual(values = c("orange2", "green4")) +
    theme_minimal() +
    theme(legend.position = "none",
          axis.title.y = element_text(vjust = 0),
          axis.text.y = element_text(angle = 90, hjust = 0.5)) +
    ggtitle("Filtered proteins") ->
    protein_sel
protein_sel
```

The range of differences between SCoPE2 and `scp` is much wider for
the protein data than for the peptide data. The range of the
differences between the `scp` and the SCoPE2 data is (-3.06, 2.66)
and this comparable to the range of the SCoPE2 protein expression
values. However, 99 \% of the differences are lying in (-0.45, 0.82)
and there is a sharp peak around 0. This indicates that the small
differences observed at peptide level have propagated during protein
imputation, batch correction and normalization. This is problematic as
it indicates that at least one of those steps is unstable. We will
the batch correction and the data imputation in a later section.

```{r, echo=FALSE, fig.width = 3, fig.height = 3}
rows <- intersect(rownames(proteins_SCoPE2),
                  rownames(scp[["proteins_scp"]]))
cols <- intersect(colnames(proteins_SCoPE2),
                  colnames(scp[["proteins_scp"]]))
err <- assay(proteins_SCoPE2)[rows, cols] -
    assay(scp[["proteins_scp"]])[rows, cols]
data.frame(difference = as.vector(err)) %>%
    mutate(difference = difference) %>%
    ggplot() +
    geom_histogram(aes(x = difference), bins = 40) +
    xlab("SCoPE2 - scp") +
    theme_minimal() +
    ggtitle("Protein data") ->
    protein_diff
protein_diff
```

To summarize, here is an overview of the differences between our
results using `scp` and the expected results obtained by the `SCoPE2`
authors.

```{r, fig.height = 6, fig.width = 9}
cell_sel +
    peptide_sel +
    protein_sel +
    plot_spacer() +
    peptide_diff +
    protein_diff +
    plot_layout(ncol = 3)
```


## PCA

To assess the separability between macrophages and monocytes, Specht and
colleagues perform weighted principal component analysis (PCA) on the protein
data. The weights are proportional to the amount of correlation between a
protein and the other proteins. Computing the weighted PCA requires some manual
implementation (taken from the SCoPE2 script). The authors use the expression
matrix as input. We can easily get this matrix from the desired assay.

```{r}
## Extract the protein expression matrix
X <- assay(scp[["proteins_scp"]])
## Compute the weights
w <- rowSums(cor(t(X))^2)
## Compute the PCs (code taken from the SCoPE2 script)
Xw <- diag(w) %*%  X
Xcor <- cor(Xw)
pcaRes <- eigen(Xcor)
pcaPercentVar <- round(pcaRes$values[1:2] / sum(pcaRes$values) * 100)
## Start plotting
data.frame(PC = pcaRes$vectors[, 1:2],
           colData(scp)[colnames(Xcor), ]) %>%
    ggplot(aes(x = PC.1, y = PC.2, col = SampleType)) +
    geom_point(alpha = 0.5) +
    ## Annotate plot
    xlab(paste0("PC1 (", pcaPercentVar[1], "%)")) +
    ylab(paste0("PC2 (", pcaPercentVar[2], "%)")) +
    ggtitle("PCA plot of the processed protein data") +
    ## Adapt the visual style to match the preprint figure
    scale_color_manual(name = "", values = c("#048ABF","#FF5733"),
                       labels = c("Macrophages", "Monocytes")) +
    theme_minimal() +
    theme(legend.position = "top")
```

This plot allow us to draw the same conclusion as in the original preprint: (i)
macropages and monocytes are well separated and (ii) macrophages are more
spread-out than monocytes. However, the plot shows notable difference with the
original figure: (i) more variance is explained by the PCA on the protein data
derived from this vignette and (ii) macrophages and monocytes are best separated
on the second PC rather than the first.

As a side note, the `scater` packages provides a suite of functions that perform
and visualize dimension reduction for `SingleCellExperiment` objects. Since our
assays are all `SingleCellExperiment` objects, we can perform regular PCA on the
protein data in just a few commands.

```{r}
library(scater)
getWithColData(scp, "proteins_scp") %>%
    ## Perform PCA, see ?runPCA for more info about arguments
    runPCA(ncomponents = 50,
           ntop = Inf,
           scale = TRUE,
           exprs_values = 1,
           name = "PCA") %>%
    ## Plotting is performed in a single line of code
    plotPCA(colour_by = "SampleType")
```

This plot is different from the previous plot because no weighting is
considered during the second PCA.

# Further data exploration

In this section we want to extend the discussion on some key aspects
of the data.

## `QFeatures` plot

The `QFeatures` plot shows the quantitative data for a features at the different
expression levels. For instance, suppose we are interested in the protein
*VIM* (protein ID is `P08670`) from one of the SCoPE2 batches (*e.g.*
`191110S_LCB7_X_APNOV16plex2_Set_9`). A useful QC is to monitor the data
processing at the PSM, peptide and protein level. This can easily be done thanks
to the `QFeatures` framework. Using the `subsetByAssay` and the `subsetByRow`
functions, we can extract the batch and feature of interest, respectively. Then,
the data is formated to a long format table that can easily be plugged in the
`ggplot2` visualization tool.

```{r, warning = FALSE, fig.width = 10, out.width = "100%"}
scp %>%
    ## Get the features related to VIM (P08670)
    subsetByFeature("P08670") %>%
    ## Format the `QFeatures` to a long format table
    longFormat(colDataCols = c("Set", "SampleType", "Channel")) %>%
    data.frame %>%
    ## Keep only the SCoPE2 set of interest
    filter(Set == "191110S_LCB7_X_APNOV16plex2_Set_9") %>%
    eez
    tmp %>%
    ## This is used to preserve ordering of the samples and assays in ggplot2
    mutate(assay = factor(assay, levels = names(scp)),
           Channel = sub("RI", "TMT-", Channel),
           Channel = factor(Channel, levels = unique(Channel))) %>%
    ## Start plotting
    ggplot(aes(x = Channel, y = value, group = rowname, col = SampleType)) +
    geom_point() +
    ## Plot every assay in a separate facet
    facet_wrap(facets = vars(assay), scales = "free_y") +
    ## Annotate plot
    xlab("Channels") +
    ylab("Intensity (arbitrary units)") +
    ## Improve plot aspect
    theme(axis.text.x = element_text(angle = 90),
          strip.text = element_text(hjust = 0),
          legend.position = "bottom")
```

This graph can help us track the processing of the data.


In later pipelines, we could imagine propagating the peptide
variability to the protein level when performing differential expression
analysis. This is has already been suggested  see for instance @Sticker2019-gd,
and we believe that our framework will facilitate the development and
benchmarking of such methodologies on MS-SCP data.


Another solution readily available from the `QFeatures` package is to
apply more suitable methods such as robust summary as an aggregation
function. We experiment this here. We will aggregate again the peptide
data

```{r}
scp <- aggregateFeatures(scp,
                         i = "peptides_log",
                         name = "proteins_robSum",
                         fcol = "protein",
                         fun = MsCoreUtils::robustSummary)
aggregateFeatures(specht2019v3(),
                  i = "peptides",
                  name = "proteins_rs",
                  fcol = "protein",
                  fun = MsCoreUtils::robustSummary)
```


## Batch effect

The SCoPE2 dataset has been acquired in 177 different MS batches.
These batches were either acquired using a TMT-11 or a TMT-16 protocol.
Furthermore, the MS batches were distributed over 4 chromatographic
batches. Acquiring data in different batches is technically inevitable
and requires to correct for it computationally. We show here the batch
effects present at the peptide level after log-transformation, but
before normalization, imputation and batch correction. We apply the
NIPALS algorithm to account for missing data.

```{r, fig.width = 10, fig.height = 10, message = FALSE, cache = TRUE}
library(nipals)
library(GGally)
sce <- getWithColData(scp, "peptides_log")
pcaRes <- nipals(t(assay(sce)),
                 ncomp = 5)
df <- data.frame(colData(sce),
                 pcaRes$scores)
```

We first check the amount of variance explained by the 5 first
components. From the graph below, we can see that almost 20 \% of the
variance is explained by the first 2 components, but the remaining
components still capture a significant proportion of the variance.

```{r}
data.frame(PC = paste0("PC", 1:5), ev = pcaRes$R2) %>%
    ggplot() +
    aes(x = PC,
        y = ev * 100) +
    geom_bar(stat = "identity") +
    ylab("Explained variance (%)")
```

Let's first look at the batch effect on the first 5 components. This
is a overview of the PCA results:

```{r, fig.width = 10, fig.height = 10, message = FALSE}
df %>%
    ggpairs(aes(color = lcbatch,
                alpha = 0.25),
            columns = paste0("PC", 1:5),
            legend = c(2,1)) +
    theme(legend.position = "bottom")
```

The chromatographic batches are perfectly separated in the first two
components:

```{r}
df %>%
    ggplot() +
    aes(x = PC1,
        y = PC2,
        col = lcbatch) +
    geom_point() +
    theme(legend.position = "bottom")
```

In the two next components, the batches are no more separated and the
biological variation seems to captured:

```{r, fig.width=8}
df %>%
    ggplot() +
    aes(x = PC3,
        y = PC4,
        col = lcbatch) +
    geom_point() +
    theme(legend.position = "bottom") +
    df %>%
    ggplot() +
    aes(x = PC3,
        y = PC4,
        col = SampleType) +
    geom_point() +
    theme(legend.position = "bottom")
```

So this means that monocytes and macrophages effect we saw in the PCA

## Missingness

### Technical missingness

```{r}
peptides <- scp[["peptides"]]
nNaRes <- nNA(peptides)
```

```{r}
nNaRes$nNAcols %>%
    data.frame(colData(scp)) %>%
    ggplot() +
    aes(x = pNA,
        fill = lcbatch) +
    geom_density(alpha = 0.5) +
    xlab("Percentage missingness (%)") +
    ggtitle("Missingness per cell")
```

```{r, fig.width=3, fig.height=4}
scp <- countUniqueFeatures(scp,
                           i = "peptides_log",
                           rowDataCol = "protein",
                           varName = "ProteinCounts")
colData(scp) %>%
    data.frame() %>%
    ggplot() +
    aes(x = ProteinCounts,
        fill = lcbatch) +
    geom_histogram() +
    facet_grid(rows = vars(lcbatch), scales = "free_y") +
    xlab("Protein count") +
    ylab("Cell count") +
    theme(legend.position = "none")
```


```{r, echo = FALSE}
library(UpSetR)
colData(scp) %>%
    data.frame %>%
    select(Set, lcbatch) %>%
    unique %>%
    group_by(lcbatch) %>%
    slice_head(n = 2) %>%
    mutate(sets = paste0(lcbatch, "_", 1:2)) ->
    batch_sel
rowData(scp)[batch_sel$Set] %>%
    lapply(function(x) x$protein) %>%
    fromList ->
    lt
cols <- RColorBrewer::brewer.pal(4, "Pastel1")[c(1, 3, 2, 4)]
names(cols) <- unique(batch_sel$lcbatch)
colnames(lt) <- batch_sel$sets
upset(lt, nsets = 8, order.by = "freq", nintersects = 20,
      sets = colnames(lt), keep.order = TRUE,
      mainbar.y.label = NULL, mb.ratio = c(0.5,0.5),
      sets.bar.color = cols[batch_sel$lcbatch],
      set.metadata = list(data = batch_sel[, c("sets", "lcbatch")],
                          plots = list(list(type = "matrix_rows",
                                            column = "lcbatch",
                                            colors = cols,
                                            alpha = 0.6))))
```


```{r}
nNaRes$nNArows %>%
    data.frame(rowData(peptides)[nNaRes$nNArows$name, ]) %>%
    mutate(Median = rowMedians(log2(assay(peptides)[nNaRes$nNArows$name, ]),
                           na.rm = TRUE)) %>%
    ggplot() +
    aes(x = Median,
        y = pNA) +
    stat_density2d(aes(fill = ..density..^0.1),
                   geom = "tile",
                   contour = FALSE) +
    scale_fill_gradientn(colours = colorRampPalette(c("white", blues9))(256)) +
    theme(legend.position = "none",
          panel.background = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_rect(colour = "black", fill = NA, size = 0.5)) +
    ylab("Percentage missingness (%)") +
    xlab("log median expression") +
    ggtitle("Missingness per peptide")
```

```{r}
proteins <- scp[["proteins"]]
mat <- matrix(0,
              nrow = nrow(proteins),
              ncol = length(unique(colData(scp)$Set)),
              dimnames = list(rownames(proteins),
                              unique(colData(scp)$Set)))
for (batch in unique(colData(scp)$Set)) {
   x <- assay(proteins)[, rownames(colData(scp)[scp$Set == batch, ])]
   mat[, batch] <- as.numeric(rowSums(is.na(x)) < ncol(x))
}
res <- rowSums(mat)
res %>%
    data.frame %>%
    ggplot() +
    aes(x = .) +
    geom_histogram(binwidth = 1) +
    xlab("Amount of batches") +
    ggtitle("Distribution of the number of proteins in batches")
```


```{r}
lf <- longFormat(proteins)
lf %>%
    mutate(rowname = factor(rowname,
                            levels = names(sort(res, decreasing = TRUE)))) %>%
    data.frame %>%
    ggplot() +
    aes(y = rowname,
        x = colname,
        fill = value) +
    geom_tile() +
    scale_fill_continuous(name = "log expression",
                          na.value = "white") +
    theme(axis.text = element_blank()) +
    xlab("Single cells") +
    ylab("Proteins") +
    ggtitle("Protein expression matrix")

assay(proteins)[, ] %>%
    t %>%
    image

```

### Biological missingness

We showed previously in this vignette that MS-SCP data is characterized by a
high rate of missing data. This missing data can be either technical or
biological. To illustrate this, we plot the rate of missingness in macrophages
against the rate of missingness in monocytes. Every point in the graph
represents a peptide. We color the peptide by the amount of change in expression
observed between the macrophages and the monocytes.

The code for plotting is rather elaborate, but notice the necessary data can
easily be extracted using only few commands.

```{r, fig.asp = 1, fig.width = 6}
sce <- getWithColData(scp, "peptides_log")
## Extract expression data from macrophages and monocytes separately
monoDat <- assay(sce[, sce$SampleType == "Monocyte"])
m0Dat <- assay(sce[, sce$SampleType == "Macrophage"])
## Create a table with the rate of missingness for each cell type and
## compute the log fold change in median expression
data.frame(m0Missing = rowMeans(is.na(m0Dat)) * 100,
           monoMissing = rowMeans(is.na(monoDat)) * 100,
           logFC = rowMedians(m0Dat, na.rm = TRUE) - rowMedians(monoDat, na.rm = TRUE)) %>%
    ## Trim log fold change to dampen the impact of outliers
    mutate(logFC = ifelse(abs(logFC) > 1, 1 * sign(logFC), logFC)) %>%
    ## Start plotting
    ggplot ->
    p
p +
    ## Plot rate of missingness in macrophages
    geom_histogram(aes(x = m0Missing), bins = 100) +
    theme_minimal() +
    theme(axis.title.x = element_blank(), axis.text.x = element_blank(),
          axis.ticks.x = element_blank()) +
    plot_spacer() +
    p +
    ## Plot missingness in macrophages vs missingness in monocytes
    geom_point(aes(x = m0Missing, y = monoMissing, col = logFC)) +
    geom_abline(slope = 1, intercept = 0, col = "grey30") +
    theme(legend.position = "bottom") +
    xlab("Missingness (%) in macrophages") +
    ylab("Missingness (%) in monocytes") +
    scale_color_gradient2(low = "#048ABF", mid = "bisque2", high = "#FF5733",
                          breaks = c(-1, 1),
                          labels = c("monocyte", "macrophage")) +
    p +
    ## Plot rate of missingness in monocytes
    geom_histogram(aes(y = monoMissing), bins = 100) +
    theme_minimal() +
    theme(axis.title.y = element_blank(), axis.text.y = element_blank(),
          axis.ticks.y = element_blank(),
          axis.text.x = element_text(angle = -90, vjust = 0.5, hjust=0)) +
    ## Adjust plotting layout
    plot_layout(widths = c(0.85, 0.15), heights = c(0.15, 0.85))
```

We can see that most of the peptides have equal missingness in macrophages and
monocytes. This is expected for technical missingness and this is further
confirmed by the fact that that the slope 1 line is dominated by peptides with
no large difference in log fold change (pale yellow). Interestingly, we can
also observe that the missingness for some peptides can be explained by
biological processes that are specific to one or the other cell type. Peptides
more expressed in macrophages (red) tend to be less missing in monocytes.
Conversely, peptides more expressed in monocytes tend to be less missing in
monocytes.

### Imputation issues

```{r, fig.height = 5, fig.width = 6}
prots <- getWithColData(scp, "proteins_impd")
nbIdentical <- apply(assay(prots),
                     1,
                     function(x) sum(duplicated(x)))
## Top 1
sel <- order(nbIdentical, decreasing = TRUE)[1]
data.frame(exprs = assay(scp[["proteins_norm2"]])[sel, ],
           colnames = colnames(prots),
           colData(prots)) %>%
    ggplot() +
    aes(x = colnames,
        col = SampleType,
        y = exprs) +
    geom_point(size = 0.9) +
    ylab("log expression") +
    xlab("") +
    theme(legend.position = "none",
          axis.ticks.x = element_blank(),
          axis.text.x = element_blank()) +
    plot_spacer() +
    data.frame(`PCDH8: Highly missing` = assay(prots)["O95206", ], ## PCDH8
           `VIM: Not missing` = assay(prots)["P08670", ], ## VIM
           colnames = colnames(prots),
           colData(prots),
           check.names = FALSE ) %>%
    pivot_longer(cols = c("PCDH8: Highly missing", "VIM: Not missing"),
                 names_to = "type") %>%
    ggplot() +
    aes(x = colnames,
        col = SampleType,
        y = value) +
    geom_point(size = 0.9) +
    facet_wrap(~ type) +
    ylab("Imputed log expression") +
    xlab("Single cell") +
    theme(legend.position = "bottom",
          axis.ticks.x = element_blank(),
          axis.text.x = element_blank()) +
    plot_layout(design = "12\n33")
```

```{r}
data.frame(exprs = assay(prots)["O95206", ], ## PCDH8
           colnames = colnames(prots),
           colData(prots)) %>%
    ggplot() +
    aes(x = exprs,
        col = SampleType,
        fill = SampleType) +
    geom_density(alpha = 0.5)
t.test(x = assay(prots)["O95206", prots$SampleType == "Macrophage"],
       y = assay(prots)["O95206", prots$SampleType == "Monocyte"])
```



# Conclusion

This vignette demonstrates the standardization of the SCoPE2 data
processing by the `scp` and `QFeatures` package. We demonstrate the


# Requirements

### Hardware and timing

This vignettte is compiled on a Lenovo YOGA 710-14IKB with Intel(R) Core(TM)
i7-7500U CPU @ 2.70GHz (4 units) and 8GB of RAM and 8GB of SWAP memory.

The total time required to compile this vignette is:

```{r, echo=FALSE}
timing <- Sys.time() - timeStart
cat(timing[[1]], attr(timing, "units"))
```

The final `specht2019v1` dataset size is:

```{r, echo=FALSE}
format(object.size(specht2019v2), units = "GB")
```


### Session info

```{r}
sessionInfo()
```

# Reference
